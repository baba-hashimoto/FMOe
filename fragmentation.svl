function json_Read;
function FMOEUtilsCommon;


function DetachMarker [color, bonds]
    local bda = first tr bonds;
    local baa = second tr bonds;

    local pos_bda = tr aPos bda;
    local pos_baa = tr aPos baa;
    local diff = pos_baa - pos_bda;

    local cap_center = pos_bda + 0.4 * diff;
    local cap_head = pos_bda + 0.2 * diff;
    local cap_axis = cap_head - cap_center;
    local sphere_center = pos_bda + 0.6 * diff;

    return apt G_Cat [
        apt G_Cap [color, cap_center, cap_axis, 0.8, 2],
        apt G_Sphere [color, sphere_center, 0.2, 2]
    ];
endfunction


function DrawDetachMarker [title_prefix, color, bonds]
    local keys = app GCreate tok_cat [title_prefix, totok igen length bonds];
    app GVertex apt cat [keys, DetachMarker [color, bonds]];
    return keys;
endfunction


function FMOFragmentationProtein chains
    chains = chains | app andE (rType cResidues chains == 'amino');
    local atoms = rAtoms (cat cResidues chains);
    local bda = apt mget [atoms, aName atoms == 'CA'];
    local baa = apt mget [atoms, aName atoms == 'C'];
    return tr [bda, baa];
endfunction


function IsCTerminalFragment fragments
    local is_amino = app andE eqE [rType aResidue fragments, ['amino']];
    local coo = andE [
      eqE [app add eqE [aMMType fragments, 'O2'], 2],
      eqE [app add eqE [aMMType fragments, 'C'], 1],
      eqE [app length fragments, 3]
    ];
    local cooh = andE [
      eqE [app add eqE [aMMType fragments, 'O'], 1],
      eqE [app add eqE [aMMType fragments, 'C'], 1],
      eqE [app add eqE [aMMType fragments, 'OH'], 1],
      eqE [app add eqE [aMMType fragments, 'HO'], 1],
      eqE [app length fragments, 4]
    ];

    return andE [is_amino, orE[coo, cooh]];
endfunction


function StripBondExtra bonds
    local bda = app first bonds;
    local baa = app second bonds;
    return tr [bda, baa];
endfunction


global function PartitionAtoms [atoms, bonds]
    local nbr = aNumber aBonds atoms;
    local ibonds = aNumber StripBondExtra bonds;
    ibonds = ibonds | app andE neE [ibonds, 0];
    nbr = graph_ecutE [nbr, tr ibonds];
    return apt get [[atoms], graph_ccomponent_list nbr];
endfunction


global function FMOFragmentation chains
    local bonds = FMOFragmentationProtein chains;
    local frags = PartitionAtoms [cat cAtoms chains, bonds];
    local terms = cat (frags | IsCTerminalFragment frags);
    local mask = not app orE app cat apt eqE [bonds, [[terms]]];
    return bonds | mask;
endfunction


global FMOE_BASISSET_DATA;


function LoadBasisSetData []
    if FMOE_BASISSET_DATA === [] then
        local data = tok_cat [GetRC ['fmoe.path', '$HOME/moefiles/fmoe'], '/basisset.json'];
        local json = freadb [data, 'line', 1];
        FMOE_BASISSET_DATA = first json_Read [json(1), []];
    endif
endfunction


function GetBasisSetNames []
    LoadBasisSetData [];
    return first untag FMOE_BASISSET_DATA;
endfunction


function GetBasisSetData name
    LoadBasisSetData [];
    return tagget [FMOE_BASISSET_DATA, name];
endfunction


function GetNumberOfFunctions [basis, atoms]
    return app add apt tagget [GetBasisSetData basis, aElement atoms];
endfunction


const MAIN_PANEL = [
    name: 'fmoe_fragmentation',
    title: 'FMOE Fragmentation',
    windowName: 'FMOEFragmentation',
    text: 'Generate',
    Vbox: [
        Hbox: [
            Label: [
                text: 'Bonds',
                extendH: 1,
                resizeH: 1
            ],
            Button: [
                name: 'auto',
                text: 'auto'
            ],
            Button: [
                name: 'add_bond',
                text: '+',
                font: 'largeFixedBold'
            ],
            Button: [
                name: 'remove_bond',
                text: '-',
                font: 'largeFixedBold',
                foreground: 'red'
            ],
            Button: [
                name: 'reset',
                text: '0',
                font: 'largeFixedBold'
            ]
        ],
        Listbox: [
            name: 'detached_bond_list',
            header: '#{+4n}\tT{-1t}\tBDA{+11t}\tBAA{+11t}',
            headerBubbleHelp: tok_cat [
                '#: index\n',
                'T: bond split type\n',
                '   A: auto\n',
                '   M: manual\n',
                'Res.: residue name\n',
                'BDA: bond detached atom\n',
                'BAA: bond attached atom'],
            onTrigger: 'return',
            multiSelect: 2,
            extendV: 1,
            resizeV: 1,
            extendH: 1,
            resizeH: 1,
            type: 'int',
            sortEnable: 1,
            len: 20,
            width: 37
        ],
        Hbox: [
            Label: [
                text: 'Fragments',
                extendH: 1,
                resizeH: 1
            ],
            Option: [
                name: 'select_basisset',
                onTrigger: 'return',
                extendH: 1,
                resizeH: 1
            ]
        ],
        Listbox: [
            name: 'fragment_list',
            header: '#{+4n}\tRes.{+4t}\tnA{+3n}\tAO{+3n}\tD{+2n}\tA{+2n}',
            headerBubbleHelp: tok_cat [
                '#: index\n',
                'Res.: majour residue name\n',
                'nA: fragment atom count\n',
                'AO: fragment atomic orbital count\n',
                'Charge: fragment formal charge'
            ],
            onTrigger: 'return',
            multiSelect: 2,
            extendV: 1,
            resizeV: 1,
            extendH: 1,
            resizeH: 1,
            type: 'int',
            sortEnable: 1,
            len: 20,
            width: 37
        ],
        Hbox: [
            Label: [text: 'template:'],
            Option: [
                name: 'select_template',
                extendH: 1,
                resizeH: 1
            ]
        ]
    ]
];


function GetTemplates path
    local templates = ftail flist path;
    if length templates > 1 then
        return templates | not eqE [templates, 'sample.ajf'];
    else
        return templates;
    endif
endfunction


function FormatDetachedBonds bonds
    local bda = first tr bonds;
    local baa = second tr bonds;
    local types = third tr bonds;
    return apt twrite [
        '{}\t{}\t{}{} {}\t{}{} {}',
        igen length bonds, types,
        rName aResidue bda, rUID aResidue bda, aName bda,
        rName aResidue baa, rUID aResidue baa, aName baa
    ];
endfunction


function appOrE v
    return app orE v;
endfunction


function FormatFragments [basisset, fragments, detached, attached]
    local amino = eqE [rType aResidue fragments, 'amino'];
    local co = app appOrE apt eqE [aName fragments, [[['C', 'O']]]];
    local non_co = apt mget [fragments, not apt andE [amino, co]];
    local res = FMOEUtilsCommon rName aResidue non_co;

    return apt twrite [
        '{}\t{}\t{}\t{}\t{}\t{}',
        igen length fragments, res, app length fragments,
        GetNumberOfFunctions [basisset, apt cat [fragments, attached]],
        app length detached, app length attached
    ];
endfunction


function RemoveAllBonds detached_bonds
    GDestroy (tr *detached_bonds)(4);
    *detached_bonds = [];
endfunction


function RemoveAutoBonds detached_bonds
    local bonds = *detached_bonds;
    local mask = third tr bonds == 'A';
    GDestroy (tr (bonds | mask))(4);
    *detached_bonds = bonds | not mask;
endfunction


function RemoveBondsByIndices [detached_bonds, indices]
    local bonds = *detached_bonds;
    local mask = zero igen length bonds;
    mask[indices] = 1;
    GDestroy (tr (bonds | mask))(4);
    *detached_bonds = bonds | not mask;
endfunction


function AutoSplitBonds [detached_bonds, chains]
    local raw_bonds = FMOFragmentation chains;
    *detached_bonds = cat [
        *detached_bonds,
        apt cat [raw_bonds, 'A', DrawDetachMarker [first cTag chains, 0xffffff, raw_bonds]]
    ];
endfunction


function AddSplitBond [detached_bonds, [bda, baa]]
    print bda;
    print baa;
    *detached_bonds = cat [
        *detached_bonds,
        [[bda, baa, 'M', DrawDetachMarker [cTag aChain bda, 0x00ffff, [[bda, baa]]]]]
    ];
endfunction


function UpdateFragments [fragments, atoms, detached_bonds]
    *fragments = PartitionAtoms [atoms, detached_bonds];
endfunction


function AssignAtomsToFragments [atoms, fragments]
    local result, i;
    for i = 1, length fragments loop
        result(i) = fragments(i) | app add apt eqE [[atoms], fragments(i)];
    endloop
    return result;
endfunction


function RefreshWindow [wkey, basisset, detached_bonds, fragments]
    local [bda, baa] = tr StripBondExtra detached_bonds;
    WindowSetAttr [wkey, [
        detached_bond_list: [text: FormatDetachedBonds detached_bonds],
        fragment_list: [text: FormatFragments [basisset, fragments,
            AssignAtomsToFragments [bda, fragments],
            AssignAtomsToFragments [baa, fragments]]
        ]
    ]];
endfunction


const BOND_PICKER_PANEL = [
    name: 'atom',
    mode: 'pickAtom',
    title: 'pick BDA...',
    location: 'MOE'
];


function CleanupBondPicker [quit, dbda, dcands]
    dvar_lock app dvar_open [quit, dbda, dcands];
    local bda = *dbda;
    if not (bda === []) then
        local [atom, colorby, color] = bda;
        aSetColorBy [atom, colorby];
        aSetRGB [atom, color];
    endif
    local cands = *dcands;
    if not (cands === []) then
        local [nbr, look] = cands;
        apt aSetNucleusLook [nbr, look];
    endif
endfunction


function FilterCandidates [bda, nbr]
    if aGeometry bda === 'sp3' then
        return nbr | aElement nbr <> 'H';
    else
        return nbr | andE [aGeometry nbr == 'sp3', aElement nbr == 'C'];
    endif
endfunction


function BondPickerTask []
    local quit = dvar_open [];
    dvar_lock quit;
    local dbda = dvar_open [];
    local dcands = dvar_open [];

    task_call [#CleanupBondPicker, [quit, dbda, dcands], [master: 'none', creator: 'detach']];

    local wkey = WindowCreate BOND_PICKER_PANEL;
    local bda = (first WindowWait wkey).atom;
    *dbda = [bda, aColorBy bda, aRGB bda];
    aSetColorBy [bda, 'rgb'];
    aSetRGB [bda, 0x999900];

    local nbr = cat aBonds bda;
    local candidates = FilterCandidates [bda, nbr];
    *dcands = [candidates, aNucleusLook candidates];
    aSetNucleusLook [candidates, 'small-sphere'];

    WindowSetAttr [wkey, [atom: [title: 'pick BAA...']]];

    local baa;
    loop
        baa = (first WindowWait wkey).atom;
        if orE eqE [baa, candidates] then
            break;
        elseif orE eqE [baa, nbr] then
            if YesNo 'Selected atom is not SP3 carbon.\ncontinue?' then
                break;
            endif
        endif
    endloop

    WindowDestroy wkey;
    dvar_unlock quit;
    return [bda, baa];
endfunction


function BondPicker []
    local [result, status] = task_call [#BondPickerTask, [], [master: 'parent', creator: 'blockEOK']];
    if status === '' then
        return result;
    endif
endfunction


function CleanupMain [quit, detached_bonds]
    dvar_lock app dvar_open [quit, detached_bonds];
    GDestroy (tr *detached_bonds)(4);
endfunction


function Sentinel [wkey, detached_bonds, fragments]
    local old_selected = [];
    loop
        local [bda, baa, _, gobj] = tr *detached_bonds;
        local rbda = andE [rRibbonMode aResidue bda <> 'none', rRibbonEnable aResidue bda];
        local rbaa = andE [rRibbonMode aResidue baa <> 'none', rRibbonEnable aResidue baa];
        GSetVisible [gobj, apt orE [rbda, not aHidden bda, rbaa, not aHidden baa]];

        local selected = SelectedAtoms [];
        if not (old_selected === selected) then
            old_selected = selected;

            WindowSetData [wkey, [
                fragment_list: (igen length *fragments) | app length AssignAtomsToFragments [selected, *fragments]
            ]];
        endif

        sleep 0.5;
    endloop
endfunction


global function FMOEFragmentationGUI[]
    local quit = dvar_open [];
    dvar_lock quit;

    local wkey = WindowCreate MAIN_PANEL;
    WindowShow wkey;

    local template_base = GetRC ['fmoe.path', '$HOME/moefiles/fmoe/ajf'];
    local templates = GetTemplates template_base;

    local detached_bonds = dvar_open [];
    local fragments = dvar_open [];

    local chains = Chains[];

    AutoSplitBonds [detached_bonds, chains];  // slow
    UpdateFragments [fragments, cat cAtoms chains, *detached_bonds];  // slow
    RefreshWindow [wkey, '6-31g*', *detached_bonds, *fragments];

    WindowSetAttr [wkey, [
        select_template: [text: templates],
        select_basisset: [text: GetBasisSetNames[]]
    ]];
    WindowSetData [wkey, [
        select_basisset: '6-31g*'
    ]];

    task_call [#CleanupMain, [quit, detached_bonds], [master: 'none', creator: 'detach']];
    task_call [#Sentinel, [wkey, detached_bonds, fragments], [master: 'parent', creator: 'detach']];

    loop
        local [values, trigger] = WindowWait wkey;

        if trigger === 'auto' then
            RemoveAutoBonds detached_bonds;
            AutoSplitBonds [detached_bonds, chains];
            UpdateFragments [fragments, cat cAtoms chains, *detached_bonds];
            RefreshWindow [wkey, values.select_basisset, *detached_bonds, *fragments];

        elseif trigger === 'reset' then
            RemoveAllBonds detached_bonds;
            UpdateFragments [fragments, cat cAtoms chains, *detached_bonds];
            RefreshWindow [wkey, values.select_basisset, *detached_bonds, *fragments];

        elseif trigger === 'remove_bond' then
            RemoveBondsByIndices [detached_bonds, first values.detached_bond_list];
            UpdateFragments [fragments, cat cAtoms chains, *detached_bonds];
            RefreshWindow [wkey, values.select_basisset, *detached_bonds, *fragments];

        elseif trigger === 'add_bond' then
            local detach = BondPicker [];
            if not (detach === []) then
                AddSplitBond [detached_bonds, detach];
                UpdateFragments [fragments, cat cAtoms chains, *detached_bonds];
                RefreshWindow [wkey, values.select_basisset, *detached_bonds, *fragments];
            endif

        elseif trigger === 'select_basisset' then
            RefreshWindow [wkey, values.select_basisset, *detached_bonds, *fragments];

        elseif trigger === 'detached_bond_list' then
            aSetSelected [Atoms [], 0];
            local selected_detached_atoms = cat StripBondExtra (*detached_bonds)[first values.detached_bond_list];
            aSetSelected [selected_detached_atoms, 1];
            WindowSetData [wkey, [
                fragment_list: (igen length *fragments) | app length AssignAtomsToFragments [selected_detached_atoms, *fragments]
            ]];

        elseif trigger === 'fragment_list' then
            aSetSelected [Atoms[], 0];
            local selected_fragmennt_atoms = cat (*fragments)[first values.fragment_list];
            aSetSelected [selected_fragmennt_atoms, 1];
            WindowSetData [wkey, [
                detached_bond_list: (igen length *detached_bonds) | app orE app orE apt eqE [[[selected_fragmennt_atoms]], StripBondExtra *detached_bonds]
            ]];

        else
            print trigger;
            print values;
        endif

    endloop
    WindowDestroy wkey;
endfunction
