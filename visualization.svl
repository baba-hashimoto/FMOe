#set title 'FMO Visualization'
#set main 'FMOVisualization'

const HARTREE = 627.509474;
const RESOLUTION = 1000;


function QuotRem [n, d]
    return [floor (n / d), mod [n, d]];
endfunction


function ParseFragAttributes [fnum, num_frags]
    local fattr = [];
    local [frag16q, frag16r] = QuotRem [num_frags, 16];

    for frag16q loop
        fattr = cat [fattr, (fread [fnum, '{n:5*16}\n'])(1)(1)];
    endloop

    if frag16r <> 0 then
        fattr = cat [
            fattr,
            (fread [fnum, tok_cat ['{n:5*', totok frag16r, '}\n']])(1)(1)
        ];
    endif

    return fattr;
endfunction


const CPF_ATOM_UID = 1;
const CPF_ATOM_ELEMENT = 2;
const CPF_ATOM_ATOMTYPE = 3;
const CPF_ATOM_RESNAME = 4;
const CPF_ATOM_RESINDEX = 5;
const CPF_ATOM_FRAGINDEX = 6;
const CPF_ATOM_X = 7;
const CPF_ATOM_Y = 8;
const CPF_ATOM_Z = 9;
const CPF_ATOM_HFMUL = 10;
const CPF_ATOM_MP2MUL = 11;
const CPF_ATOM_HFNBO = 12;
const CPF_ATOM_MP2NBO = 13;
const CPF_ATOM_HFESP = 14;
const CPF_ATOM_MP2ESP = 15;

const CPF_VERSION = 1;
const CPF_COMMENT = 2;
const CPF_NUM_ATOMS = 3;
const CPF_NUM_FRAGMENTS = 4;
const CPF_ATOMS = 5;

const CPF_MONOMER_ATOM_INDICES = 6;
const CPF_MONOMER_NUM_ELECTRONS = 7;
const CPF_MONOMER_NUM_BONDS = 8;
const CPF_MONOMER_HF_DIPOLES = 9;
const CPF_MONOMER_MP2_DIPOLES = 10;
const CPF_MONOMER_REPULSION = 11;
const CPF_MONOMER_ELECTRONIC = 12;
const CPF_MONOMER_MP2 = 13;
const CPF_MONOMER_MP3 = 14;
const CPF_MONOMER_AO = 15;
const CPF_MONOMER_MO = 16;

const CPF_BDA_BAAS = 17;

const CPF_DIMER_DISTANCES = 18;
const CPF_DIMER_REPULSION = 19;
const CPF_DIMER_ELECTRONIC = 20;
const CPF_DIMER_ELECTROSTATIC = 21;
const CPF_DIMER_MP2 = 22;
const CPF_DIMER_SCS_MP2 = 23;
const CPF_DIMER_MP3 = 24;
const CPF_DIMER_SCS_MP3 = 25;
const CPF_DIMER_HF_BSSE = 26;
const CPF_DIMER_MP2_BSSE = 27;
const CPF_DIMER_SCS_MP2_BSSE = 28;
const CPF_DIMER_MP3_BSSE = 29;
const CPF_DIMER_SCS_MP3_BSSE = 30;
const CPF_DIMER_EXCHANGE_REPULSION = 31;
const CPF_DIMER_CHARGE_TRANSFER = 32;
const CPF_DIMER_AMOUNT_OF_CHARGE_TRANSFER = 33;

const CPF_BASIS_SET = 34;
const CPF_ELECTRONIC_STATE = 35;
const CPF_METHOD = 36;

const CPF_APPROXIMATION_AO_POPULATION = 37;
const CPF_APPROXIMATION_POINT_CHARGE = 38;
const CPF_APPROXIMATION_DIMERES = 39;

const CPF_ENERGY_REPULSION = 40;
const CPF_ENERGY_ELECTRONIC = 41;
const CPF_ENERGY_TOTAL = 42;


global function ParseAbinitMpCheckPoint fnum
    local [version, comment] = (fread [fnum, 'CPF Ver.{t:}{t:}\n'])(1);
    local [num_atoms, num_frags] = (fread [fnum, '{n:5}{n:5}\n'])(1);
    local num_dimers = num_frags * (num_frags - 1) / 2;

    local atoms = [], frag_atoms = [];
    local i;
    for i = 1, num_atoms loop
        local [
            uid, element, atom_type, res_name, res_index, frag_index,
            [x, y, z, hf_mul, mp2_mul, hf_nbo, mp2_nbo, hf_esp, mp2_esp]
        ] = (fread [fnum, '{n:5} {t:2} {c:*4} {t:3} {n:4} {n:4} {n:12*9}\n'])(1);
        atoms(i) = [
            uid, element, token atom_type, res_name, res_index, frag_index, x, y, z,
            hf_mul, mp2_mul, hf_nbo, mp2_nbo, hf_esp, mp2_esp
        ];
        frag_atoms(frag_index) = append[frag_atoms(frag_index), i];
    endloop

    local m_atom_indices = frag_atoms,
          m_num_electrons = ParseFragAttributes [fnum, num_frags],
          m_num_bonds = ParseFragAttributes [fnum, num_frags];
    local num_bonds = add m_num_bonds;
    local bda_baas = [];

    for num_bonds loop
        // TODO: inverse?
        local [bda, baa] = (fread [fnum, '{n:5}{n:5}\n'])(1);
        bda_baas = append [bda_baas, [bda, baa]];
    endloop

    local idx = 0, j, d_distances = igen num_dimers;
    for i = 2, num_frags loop
        for j = 1, i - 1 loop
            idx = idx + 1;
            d_distances(idx) = (fread [fnum, '{n:*3}\n'])(1)(1)(3);
        endloop
    endloop

    local dipoles = [], m_hf_dipoles, m_mp2_dipoles;
    for num_frags loop
        local [hf_x, hf_y, hf_z, mp2_x, mp2_y, mp2_z] = (fread [fnum, '{n:*6}'])(1)(1);
        m_hf_dipoles = append[m_hf_dipoles, [hf_x, hf_y, hf_z]];
        m_mp2_dipoles = append[m_mp2_dipoles, [mp2_x, mp2_y, mp2_z]];
    endloop

    local [basisset, electronic_state, method] = freadb [fnum, 'line', 3];
    local [ao_popl_approx, point_charge_approx, dimeres_approx] = (fread [fnum, '{n:*3}'])(1)(1);
    local repulsion_energy = (fread [fnum, '{n:}\n'])(1);
    local electronic_energy = (fread [fnum, '{n:}\n'])(1);
    local total_energy = (fread [fnum, '{n:}\n'])(1);

    local m_repulsions, m_electronics, m_mp2s, m_mp3s, m_aos, m_mos;

    for num_frags loop
        local [[m_repl, m_ele, m_mp2, m_mp3], [m_ao, m_mo]] = (fread [fnum, '{n:24*4}{n:12*2}\n'])(1);
        m_repulsions = append [m_repulsions, m_repl];
        m_electronics = append [m_electronics, m_ele];
        m_mp2s = append[m_mp2s, m_mp2];
        m_mp3s = append[m_mp3s, m_mp3];
        m_aos = append[m_aos, m_ao];
        m_mos = append[m_mos, m_mo];
    endloop

    local repl, ele, es, mp2, scs_mp2, mp3, scs_mp3, hf_bsse, mp2_bsse, scs_mp2_bsse, mp3_bsse, scs_mp3_bsse;
    local pieda_ex, pieda_ct_mix, pieda_amount_of_ct;
    local
        d_repulsion = igen num_dimers,
        d_electronic = igen num_dimers,
        d_electrostatic = igen num_dimers,
        d_mp2 = igen num_dimers,
        d_scs_mp2 = igen num_dimers,
        d_mp3 = igen num_dimers,
        d_scs_mp3 = igen num_dimers,
        d_hf_bsse = igen num_dimers,
        d_mp2_bsse = igen num_dimers,
        d_scs_mp2_bsse = igen num_dimers,
        d_mp3_bsse = igen num_dimers,
        d_scs_mp3_bsse = igen num_dimers,
        d_ex = igen num_dimers,
        d_ct = igen num_dimers,
        d_qij = igen num_dimers;

    local start = cpuclock[];
    idx = 0;
    for i = 2, num_frags loop
        for j = 1, i - 1 loop
            idx = idx + 1;
            if version == '4.201' then
                [
                    repl, ele, es,
                    mp2, scs_mp2,
                    mp3, scs_mp3,
                    hf_bsse, mp2_bsse, scs_mp2_bsse, mp3_bsse, scs_mp3_bsse,
                    pieda_ex, pieda_ct_mix, pieda_amount_of_ct
                ] = (fread [fnum, '{n:24*15}\n'])(1)(1);
            else  // 4.2
                [
                    repl, ele, es,
                    mp2, scs_mp2,
                    mp3, scs_mp3,
                    hf_bsse, mp2_bsse, scs_mp2_bsse, mp3_bsse, scs_mp3_bsse
                ] = (fread [fnum, '{n:24*12}\n'])(1)(1);
            endif

            d_repulsion(idx) = repl;
            d_electronic(idx) = ele;
            d_electrostatic(idx) = es;
            d_mp2(idx) = mp2;
            d_scs_mp2(idx) = scs_mp2;
            d_mp3(idx) = mp3;
            d_scs_mp3(idx) = scs_mp3;
            d_hf_bsse(idx) = hf_bsse;
            d_mp2_bsse(idx) = mp2_bsse;
            d_scs_mp2_bsse(idx) = scs_mp2_bsse;
            d_mp3_bsse(idx) = mp3_bsse;
            d_scs_mp3_bsse(idx) = scs_mp3_bsse;

            if version == '4.201' then
                d_ex(idx) = pieda_ex;
                d_ct(idx) = pieda_ct_mix;
                d_qij(idx) = pieda_amount_of_ct;
            endif
        endloop
    endloop

    return [
        version,
        comment,
        num_atoms,
        num_frags,

        atoms,

        m_atom_indices,
        m_num_electrons,
        m_num_bonds,
        m_hf_dipoles,
        m_mp2_dipoles,
        m_repulsions,
        m_electronics,
        m_mp2s,
        m_mp3s,
        m_aos,
        m_mos,

        bda_baas,

        d_distances,
        d_repulsion,
        d_electronic,
        d_electrostatic,
        d_mp2,
        d_scs_mp2,
        d_mp3,
        d_scs_mp3,
        d_hf_bsse,
        d_mp2_bsse,
        d_scs_mp2_bsse,
        d_mp3_bsse,
        d_scs_mp3_bsse,
        d_ex,
        d_ct,
        d_qij,

        basisset,
        electronic_state,
        method,

        ao_popl_approx,
        point_charge_approx,
        dimeres_approx,

        repulsion_energy,
        electronic_energy,
        total_energy
    ];
endfunction


const STANDARD_RESIDUES = [
    'ALA', 'ARG', 'ASN', 'ASP', 'CYS',
    'GLN', 'GLU', 'GLY', 'HIS', 'ILE',
    'LEU', 'LYS', 'MET', 'PHE', 'PRO',
    'SER', 'THR', 'TRP', 'TYR', 'VAL',
    'ACE', 'NME'
];


function _IsStandardResidue res
    return orE eqE [STANDARD_RESIDUES, res];
endfunction


function IsStandardResidue res
    return app _IsStandardResidue res;
endfunction


global function AbinitMpCheckPointFileToPDBFile [cpf, fnum]
    local atom;
    for atom in cpf(CPF_ATOMS) loop
        local header;
        if IsStandardResidue atom(CPF_ATOM_RESNAME) then
            header = 'ATOM  ';
        else
            header = 'HETATM';
        endif

        fwrite [
            fnum,
            '{t:}{n:5} {t:4} {t:3} A{n:4}    {n:8.3f}{n:8.3f}{n:8.3f}  1.00  1.00          {t:2}\n',
            header, atom(CPF_ATOM_UID), atom(CPF_ATOM_ATOMTYPE), atom(CPF_ATOM_RESNAME), atom(CPF_ATOM_RESINDEX),
            atom(CPF_ATOM_X), atom(CPF_ATOM_Y), atom(CPF_ATOM_Z), atom(CPF_ATOM_ELEMENT)
        ];
    endloop
endfunction


function WriteTempPDBFile cpf
    local pdb_path = fnametemp '$TMP/fmoe_visualization_*.pdb';
    local pdb_file = fopenw pdb_path;
    AbinitMpCheckPointFileToPDBFile [cpf, pdb_file];
    fclose pdb_file;
    return pdb_path;
endfunction


function OpenCPF cpf
    local pdb_file = WriteTempPDBFile cpf;
    local chains = ReadPDB pdb_file;
    fdelete pdb_file;
    return chains;
endfunction


function RGBToNumber [r, g, b]
    return floor [r * 0xff] * 0x10000 + floor [g * 0xff] * 0x100 + floor [b * 0xff];
endfunction


function NumberToRGB n
    return [
        floor [n / 0x10000] / 0xff,
        bitand [floor [n / 0x100], 0xff] / 0xff,
        bitand [n, 0xff] / 0xff
    ];
endfunction


function DimerIndex [i, j]
    if j > i then
        [i, j] = [j, i];
    endif

    return ((i - 1) * (i - 2)) / 2 + j;
endfunction


function DimerLengthToNumFragments [l]
    return (sqrt [8 * l + 1] + 1) / 2;
endfunction


function _IfieWith [ifies, i]
    local num_frags = DimerLengthToNumFragments length ifies;
    local result = ifies [app DimerIndex tr [i, igen num_frags]];

    result(i) = [];

    return result;
endfunction


global function IfieWith [ifies, v]
    if length v == 1 then
        return _IfieWith [ifies, v];
    else
        local result = [];
        local i;
        for i in v loop
            result = append [result, _IfieWith [ifies, i]];
        endloop
        return add result;
    endif
endfunction


function InterpolateRGB [rgb0, rgb1, r]
    local [r0, g0, b0] = rgb0;
    local [r1, g1, b1] = rgb1;
    local dr = r1 - r0;
    local dg = g1 - g0;
    local db = b1 - b0;

    return tr [r0 + dr * r, g0 + dg * r, b0 + db * r];
endfunction


function _RGBColorScale [[rgbmin, rgb0, rgbmax], v]
    if v > 0.5 then
        return InterpolateRGB [rgb0, rgbmax, 2 * (v - 0.5)];
    else
        return InterpolateRGB [rgbmin, rgb0, 2 * v];
    endif
endfunction


function RGBColorScale [rgbmin, rgb0, rgbmax, v]
    return app cat apt _RGBColorScale [[[rgbmin, rgb0, rgbmax]], v];
endfunction


function LinearScale [range, v]
    local xmax = range;
    local xmin = -range;

    local result = (v + range) / (2 * range);
    result | (result > 1) = 1;
    result | (result < 0) = 0;
    return result;
endfunction


function GetRange ifie
    return max [abs max cat ifie, abs min cat ifie];
endfunction


global function SetRGBByIfie [ifie, cpf, chains, options]
    local range = options.range,
        rgbmin = options.rgbmin,
        rgb0 = options.rgb0,
        rgbmax = options.rgbmax,
        ligandrgb = options.ligandrgb;

    if range === [] then
        range = GetRange ifie;
    endif
    if rgbmin === [] then
        rgbmin = 0x0000ff;
    endif
    if rgb0 === [] then
        rgb0 = 0xffffff;
    endif
    if rgbmax === [] then
        rgbmax = 0xff0000;
    endif
    if ligandrgb === [] then
        ligandrgb = 0xffff00;
    endif

    rgbmin = NumberToRGB rgbmin;
    rgb0 = NumberToRGB rgb0;
    rgbmax = NumberToRGB rgbmax;

    local ligandmask = not app isscalar ifie;
    ifie | ligandmask = (ifie | not ligandmask)(1);

    local scale = LinearScale [range, ifie];
    local colors = app RGBToNumber RGBColorScale [rgbmin, rgb0, rgbmax, scale];

    local atom_keys = cat cAtoms chains;
    local res_keys = cat cResidues chains;

    local i;
    for i = 1, cpf(CPF_NUM_FRAGMENTS) loop
        local color = colors(i);
        if ligandmask(i) then
            color = ligandrgb;
        endif

        local frag_atoms = atom_keys[cpf(CPF_MONOMER_ATOM_INDICES)(i)];

        aSetRGB [frag_atoms, color];
        rSetRibbonRGB [res_keys(i), color];
        // color | color == 0 = 0x010101;  // FIXME: avoid bug
        rSetRGB [res_keys(i), color];
    endloop
endfunction


const MAIN_PANEL = [
    title: 'FMO Visualization',
    windowName: 'FMOVisualization',
    Vbox: [
        extendH: 1,
        Hbox: [
            extendH: 1,
            Label: [text: 'Ligand:', font: 'mediumBold'],
            Button: [name: 'set_ligand', onTrigger: 'return'],
            Button: [name: 'add_ligand', onTrigger: 'return', text: '+'],
            Color: [name: 'ligandrgb', onTrigger: 'return']
        ],
        Hbox: [
            extendH: 1,
            Label: [text: 'Energy:', font: 'mediumBold'],
            Radio: [name: 'visualize_energy', type: 'char', text: ['MP2', 'HF', 'ES', 'EX', 'CT+mix', 'DI'], onTrigger: 'return']
        ],
        Separator: [
            extendH: 1
        ],
        Hbox: [
            extendH: 1,
            Vbox: [Color: [name: 'rgbmin', centerH: 1, onTrigger: 'return'], Text: [type: 'real', name: 'energymin', len: 10, onTrigger: 'return']],
            Vbox: [
                extendH: 1,
                Slider: [extendH: 1, centerV: 1, name: 'leftslider', range: [-RESOLUTION, -1, 1], onTrigger: 'return'],
                Wheel: [extendH: 1, centerV: 1, name: 'leftwheel', resetButton: 0, onTrigger: 'return']
            ],
            Vbox: [Color: [name: 'rgb0', centerH: 1, onTrigger: 'return'], Button: [text: '0', name: 'reset_energy', centerH: 1, extendH: 1, onTrigger: 'return']],
            Vbox: [
                extendH: 1,
                Slider: [extendH: 1, centerV: 1, name: 'rightslider', range: [1, RESOLUTION, 1], onTrigger: 'return'],
                Wheel: [extendH: 1, centerV: 1, name: 'rightwheel', resetButton: 0, onTrigger: 'return']
            ],
            Vbox: [Color: [name: 'rgbmax', centerH: 1, onTrigger: 'return'], Text: [type: 'real', name: 'energymax', len: 10, onTrigger: 'return']]
        ]
    ]
];


const LIGAND_PICKER = [
    name: 'atom',
    location: 'MOE',
    mode: 'pickAtom',
    title: 'pick one of ligand atoms...'
];


function GetIfie [cpf, key]
    local e;
    if key == 'MP2' then
        e = cpf(CPF_DIMER_ELECTROSTATIC) + cpf(CPF_DIMER_EXCHANGE_REPULSION) + cpf(CPF_DIMER_CHARGE_TRANSFER) + cpf(CPF_DIMER_MP2);
    elseif key == 'HF' then
        e = cpf(CPF_DIMER_ELECTROSTATIC) + cpf(CPF_DIMER_EXCHANGE_REPULSION) + cpf(CPF_DIMER_CHARGE_TRANSFER);
    elseif key == 'ES' then
        e = cpf(CPF_DIMER_ELECTROSTATIC);
    elseif key == 'EX' then
        e = cpf(CPF_DIMER_EXCHANGE_REPULSION);
    elseif key == 'CT+mix' then
        e = cpf(CPF_DIMER_CHARGE_TRANSFER);
    elseif key == 'DI' then
        e = cpf(CPF_DIMER_MP2);
    endif
    e | abs e > 10 = 0;
    return e * HARTREE;
endfunction


global function GetCpfAtomByAtomKey [cpf, chains, atom_key]
    local idx = indexof [atom_key, cat cAtoms chains];
    return cpf(CPF_ATOMS)(idx);
endfunction


function PickLigandTask []
    local wkey = WindowCreate LIGAND_PICKER;
    local result = (first WindowWait wkey).atom;
    WindowDestroy wkey;
    return result;
endfunction


function PickLigand [cpf, chains]
    local [atom_key, return_code] = task_call [#PickLigandTask, [], [master: 'parent']];
    if return_code == '' then
        return GetCpfAtomByAtomKey[cpf, chains, atom_key];
    else
        return [];
    endif
endfunction


function DetectLigandAtom [cpf]
    local atom;
    local res_names = cat (tr cpf(CPF_ATOMS))[CPF_ATOM_RESNAME];
    local non_standards = cpf(CPF_ATOMS) | (not app orE apt eqE [res_names, [STANDARD_RESIDUES]]);
    local sizes;
    for atom in non_standards loop
        local uid = atom(CPF_ATOM_UID);
        local idx = totok atom(CPF_ATOM_RESINDEX);
        local [_, n] = tagpeek [sizes, idx];
        if n === [] then
            n = 0;
        endif
        sizes = tagpoke [sizes, idx, [uid, n + 1]];
    endloop

    if sizes === [] then
        return [];
    endif

    idx = first second sizes(x_max app second second untag sizes);
    return cpf(CPF_ATOMS)(idx);
endfunction


function ShowVisualizationPanel [cpf, chains, options]
    local wkey = WindowCreate MAIN_PANEL;

    local ifie_cat = 'MP2';
    local rgbmin = 0x0000ff;
    local rgb0 = 0xffffff;
    local rgbmax = 0xff0000;
    local detected_ligand_atom = DetectLigandAtom [cpf];
    local ligands;
    local ligand_names;
    if detected_ligand_atom === [] then
        ligands = [cpf(CPF_ATOMS)(1)(CPF_ATOM_FRAGINDEX)];
        ligand_names = [swrite ['{} {}', cpf(CPF_ATOMS)(1)(CPF_ATOM_RESNAME), cpf(CPF_ATOMS)(1)(CPF_ATOM_RESINDEX)]];
    else
        ligands = [detected_ligand_atom(CPF_ATOM_FRAGINDEX)];
        ligand_names = [swrite ['{} {}', detected_ligand_atom(CPF_ATOM_RESNAME), detected_ligand_atom(CPF_ATOM_RESINDEX)]];
    endif

    local new_ligand;
    local ligandrgb = 0xffff00;

    local ifie = IfieWith [GetIfie [cpf, ifie_cat], ligands];
    local range = GetRange ifie;
    local value = range;

    WindowShow wkey;
    loop
        SetRGBByIfie [ifie, cpf, chains, [range: value, rgbmin: rgbmin, rgb0: rgb0, rgbmax: rgbmax, ligandrgb: ligandrgb]];
        WindowSetData [wkey, [
            visualize_energy: ifie_cat,
            energymin: -value, energymax: value,
            leftslider: -value / range * RESOLUTION,
            rightslider: value / range * RESOLUTION,
            ligandrgb: ligandrgb, rgbmin: rgbmin, rgb0: rgb0, rgbmax: rgbmax
            ]
        ];
        WindowSetAttr [wkey, [set_ligand: [text: token cat droplast cat tr [ligand_names, ","]]]];
        local [values, trigger] = WindowWait wkey;
        if trigger == 'leftslider' then
            value = range * (-values.leftslider) / RESOLUTION;
        elseif trigger == 'rightslider' then
            value = range * values.rightslider / RESOLUTION;
        elseif trigger == 'leftwheel' then
            value = value - values.leftwheel;
        elseif trigger == 'rightwheel' then
            value = value + values.rightwheel;
        elseif trigger == 'energymin' then
            value = -values.energymin;
        elseif trigger == 'energymax' then
            value = values.energymax;
        elseif trigger == 'reset_energy' then
            value = range;
        elseif trigger == 'rgbmin' then
            rgbmin = values.rgbmin;
        elseif trigger == 'rgb0' then
            rgb0 = values.rgb0;
        elseif trigger == 'rgbmax' then
            rgb0 = values.rgbmax;
        elseif trigger == 'ligandrgb' then
            ligandrgb = values.ligandrgb;
        elseif trigger == 'visualize_energy' then
            ifie_cat = values.visualize_energy;
            ifie = IfieWith [GetIfie [cpf, ifie_cat], ligands];
            range = GetRange ifie * 2;
        elseif trigger == 'set_ligand' then
            new_ligand = PickLigand[cpf, chains];
            if not [new_ligand === []] then
                ligands = [new_ligand(CPF_ATOM_FRAGINDEX)];
                ligand_names = [swrite ['{} {}', new_ligand(CPF_ATOM_RESNAME), new_ligand(CPF_ATOM_RESINDEX)]];
            endif
        elseif trigger == 'add_ligand' then
            new_ligand = PickLigand[cpf, chains];
            if not orE eqE [ligands, new_ligand(CPF_ATOM_FRAGINDEX)] then
                ligands = append [ligands, new_ligand(CPF_ATOM_FRAGINDEX)];
                ligand_names = append [ligand_names, swrite ['{} {}', new_ligand(CPF_ATOM_RESNAME), new_ligand(CPF_ATOM_RESINDEX)]];
            endif
        endif

        if orE[trigger == 'set_ligand', trigger == 'add_ligand'] then
            ifie = IfieWith [GetIfie [cpf, ifie_cat], ligands];
            range = GetRange ifie;
            value = range;
        endif

        if value < 0 then
            value = 0.01;
        endif
        WindowSetData [wkey, [leftwheel: 0, rightwheel: 0]];
    endloop
    WindowDestroy wkey;
endfunction


function Cpf2SvlExePath []
    local exe = tok_cat ['$HOME/moefiles/fmoe/bin/cpf2svl.', MOE_ARCH, '.exe'];
    if ftype exe === 'file' then
        return exe;
    endif
endfunction


global function ParseAbinitMpCheckPointFileExe path
    local exe = Cpf2SvlExePath [];
    if exe === [] then
        return;
    endif
    local svl_path = fnametemp '$TMP/fmoe_parsed_cpf*.svlb';
    local pkey = exe_open_shell [exe, [], [CPF_PATH: path, SVL_PATH: svl_path]];
    while exe_status pkey loop
        sleep 0.01;
    endloop
    if not exe_exitcode pkey then
        return freadb [svl_path, 'SVL', 50];
    endif
endfunction


global function ParseAbinitMpCheckPointFileSVL path
    local file = fopenr path;
    local cpf = ParseAbinitMpCheckPoint file;
    fclose file;
    return cpf;
endfunction


global function ParseAbinitMpCheckPointFile path
    local msg = Message [0, twrite ['Parsing CPF file {}...', path]];
    local exe = Cpf2SvlExePath[];
    local result;
    if exe === [] then
        result = ParseAbinitMpCheckPointFileSVL path;
    else
        result = ParseAbinitMpCheckPointFileExe path;
    endif
    Message [msg, []];
    return result;
endfunction


global function FMOVisualization [path]
    if path === [] then
        path = FilePrompt [title: 'open cpf file', mode: 'open', filter: '*.cpf'];
    else
        path = fabsname path;
    endif

    if path === [] then
        return;
    endif

    local cpf = ParseAbinitMpCheckPointFile path;

    local chains = OpenCPF cpf;
    rSetRibbonColorBy [cResidues chains, 'rgb'];
    aSetColorBy [cat cAtoms chains | app orE apt eqE [[totok "CH"], aElement cat cAtoms chains], 'a:rgb'];

    ShowVisualizationPanel [cpf, chains, []];
endfunction
